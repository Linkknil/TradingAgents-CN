# LangChain 高级记忆管理使用指南

## 概述

本项目实现了四种高级记忆管理类型，每种都有不同的特点和适用场景：

1. **ConversationBufferMemory** - 基础缓冲记忆
2. **ConversationSummaryMemory** - 摘要记忆
3. **ConversationSummaryBufferMemory** - 混合记忆
4. **VectorStoreRetrieverMemory** - 向量记忆

## 记忆类型详解

### 1. ConversationBufferMemory（基础缓冲记忆）

**特点：**
- 保留所有对话历史
- 内存占用随对话增长
- 适合短期对话

**配置：**
```bash
MEMORY_TYPE=buffer
```

**使用场景：**
- 短期对话（< 50轮）
- 需要完整对话历史的场景
- 调试和开发阶段

### 2. ConversationSummaryMemory（摘要记忆）

**特点：**
- 将历史对话压缩为摘要
- 节省内存空间
- 可能丢失细节信息

**配置：**
```bash
MEMORY_TYPE=summary
```

**使用场景：**
- 长期对话（> 100轮）
- 内存受限环境
- 只需要主要话题的上下文

### 3. ConversationSummaryBufferMemory（混合记忆）

**特点：**
- 最近对话完整保留
- 历史对话压缩为摘要
- 平衡内存和细节

**配置：**
```bash
MEMORY_TYPE=summary_buffer
MEMORY_MAX_TOKEN_LIMIT=1000  # 最近对话的最大token数
```

**使用场景：**
- 中等长度对话（50-200轮）
- 需要最近细节和长期上下文
- 生产环境推荐

### 4. VectorStoreRetrieverMemory（向量记忆）

**特点：**
- 基于语义相似性检索历史
- 智能选择相关对话
- 需要向量数据库支持

**配置：**
```bash
MEMORY_TYPE=vector
MEMORY_RETRIEVER_K=5  # 检索相关对话数量
```

**使用场景：**
- 复杂多话题对话
- 需要智能上下文选择
- 有向量数据库环境

## 环境变量配置

在 `.env` 文件中设置：

```bash
# 记忆类型选择
MEMORY_TYPE=buffer  # buffer/summary/summary_buffer/vector

# 混合记忆配置
MEMORY_MAX_TOKEN_LIMIT=1000  # 最近对话的最大token数

# 向量记忆配置
MEMORY_RETRIEVER_K=5  # 检索相关对话数量
```

## API 接口使用

### 1. 基础对话接口

```bash
# 发送消息
curl -X POST "http://localhost:8000/chat" \
  -H "Content-Type: application/json" \
  -d '{"input": "你好，我想了解LangChain"}'
```

### 2. 记忆管理接口

```bash
# 获取记忆信息
curl -X GET "http://localhost:8000/memory/info"

# 清空记忆
curl -X POST "http://localhost:8000/memory/clear"
```

## 使用示例

### Python 客户端示例

```python
import requests
import json

# 基础对话
def chat(message):
    response = requests.post(
        "http://localhost:8000/chat",
        json={"input": message}
    )
    return response.json()["output"]

# 获取记忆信息
def get_memory_info():
    response = requests.get("http://localhost:8000/memory/info")
    return response.json()

# 清空记忆
def clear_memory():
    response = requests.post("http://localhost:8000/memory/clear")
    return response.json()

# 使用示例
if __name__ == "__main__":
    # 查看当前记忆类型
    memory_info = get_memory_info()
    print(f"当前记忆类型: {memory_info['memory_info']['type']}")
    
    # 进行对话
    response1 = chat("我叫张三，是一名程序员")
    print(f"AI回复: {response1}")
    
    response2 = chat("你还记得我的名字吗？")
    print(f"AI回复: {response2}")
    
    # 清空记忆
    clear_result = clear_memory()
    print(f"清空结果: {clear_result}")
```

### JavaScript 客户端示例

```javascript
// 基础对话
async function chat(message) {
    const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ input: message })
    });
    const data = await response.json();
    return data.output;
}

// 获取记忆信息
async function getMemoryInfo() {
    const response = await fetch('http://localhost:8000/memory/info');
    return await response.json();
}

// 清空记忆
async function clearMemory() {
    const response = await fetch('http://localhost:8000/memory/clear', {
        method: 'POST'
    });
    return await response.json();
}

// 使用示例
async function example() {
    // 查看记忆信息
    const memoryInfo = await getMemoryInfo();
    console.log('当前记忆类型:', memoryInfo.memory_info.type);
    
    // 进行对话
    const response1 = await chat('我叫李四，是一名设计师');
    console.log('AI回复:', response1);
    
    const response2 = await chat('你还记得我的职业吗？');
    console.log('AI回复:', response2);
    
    // 清空记忆
    const clearResult = await clearMemory();
    console.log('清空结果:', clearResult);
}
```

## 性能对比

| 记忆类型 | 内存占用 | 响应速度 | 上下文质量 | 适用场景 |
|---------|---------|---------|-----------|---------|
| Buffer | 高 | 快 | 完整 | 短期对话 |
| Summary | 低 | 中等 | 一般 | 长期对话 |
| SummaryBuffer | 中等 | 中等 | 良好 | 生产环境 |
| Vector | 中等 | 慢 | 智能 | 复杂对话 |

## 最佳实践

1. **开发阶段**：使用 `buffer` 类型，便于调试
2. **生产环境**：使用 `summary_buffer` 类型，平衡性能和功能
3. **复杂场景**：使用 `vector` 类型，智能上下文选择
4. **内存受限**：使用 `summary` 类型，节省资源

## 故障排除

### 常见问题

1. **向量记忆初始化失败**
   - 检查向量数据库是否正常运行
   - 确认 Embedding 配置正确

2. **摘要记忆生成失败**
   - 检查 LLM 配置和 API Key
   - 确认模型支持摘要功能

3. **记忆清空失败**
   - 检查记忆管理器状态
   - 查看日志错误信息

### 调试方法

```python
# 检查记忆状态
from app.memory.convo import get_memory_info, clear_memory

# 获取详细信息
memory_info = get_memory_info(memory)
print(f"记忆类型: {memory_info['type']}")
print(f"记忆键: {memory_info['memory_key']}")

# 清空记忆
success = clear_memory(memory)
print(f"清空结果: {success}")
```

## 扩展功能

未来可以添加的功能：

1. **实体记忆**：记住特定实体信息
2. **时间记忆**：基于时间的记忆管理
3. **用户记忆**：多用户记忆隔离
4. **记忆持久化**：跨会话记忆保持
5. **记忆分析**：对话模式分析

## 总结

通过合理选择记忆类型，可以显著提升对话系统的性能和用户体验。建议根据实际需求选择合适的记忆管理策略。
